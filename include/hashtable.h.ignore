
#ifndef PROJECT_INCLUDES_HASHTABLE_H
#define PROJECT_INCLUDES_HASHTABLE_H

#ifndef HASH_MODULUS
#define HASH_MODULUS (52379)
#else
#error "HASH_MODULUS already defined."
#endif // HASH_MODULUS

size_t hash(char* s) {
    size_t hashval = 0;

    while (*s) {
        hashval = (*s++) + 211 * hashval;
    }
    
    return hashval % HASH_MODULUS;
}

/** Perfect 8x4 alignment
 * 
 */
struct table_entry_t {
    char* word;
    size_t count1;
    size_t count2;
    struct table_entry_t* next;
};

struct table_entry_t* allocate_table_entry(void) {
    struct table_entry_t* entry = malloc(sizeof (struct table_entry_t));

    if (entry == NULL) {
        fprintf(stderr, "Memory allocation failure in allocate_table_entry()\n");
        exit(EXIT_FAILURE);
    }

    return entry;
}

struct table_entry_t* create_table_entry(char* word) {
    struct table_entry_t* entry = allocate_table_entry();

    entry->count1 = 0;
    entry->count2 = 0;
    entry->word   = strdup(word);

    if (entry->word == NULL) {
        fprintf(stderr, "Memory allocation failure in create_table_entry->strdup(word)\n");
        exit(EXIT_FAILURE);
    }

    return entry;
}

static struct table_entry_t *hash_table[HASH_MODULUS];

struct table_entry_t* lookup_word(char* word) {
    struct table_entry_t* entry = hash_table[hash(word)];

    while (entry) {
        if (strings_match(word, entry->word)) {
            return entry;
        }

        entry = entry->next;
    }

    return NULL;
}

struct table_entry_t* add_word_to_table(char* word) {
    struct table_entry_t* entry = lookup_word(word);

    if (entry == NULL) {
        entry = create_table_entry(word);

        size_t hashval = hash(entry->word);
        entry->next = hash_table[hashval];
        hash_table[hashval] = entry;
    }

    if (first_file) {
        ++entry->count1;
    } else {
        ++entry->count2;
    }

    if (entry->count1 && entry->count2) {
        double entry_commonality_score = commonality(entry);

        if (entry_commonality_score > current_max) {
            current_max = entry_commonality_score;
            most_common_word = entry->word;
        }
    }

    return entry;
}

#endif // PROJECT_INCLUDES_HASHTABLE_H
